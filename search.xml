<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 问题集</title>
    <url>/2020/06/21/Cpp-Problems-Collection/</url>
    <content><![CDATA[<h3 id="n-与-stdendl-的区别"><code>'\n\'</code> 与 <code>std::endl</code> 的区别</h3>
<ul>
<li>''表示内容为一个回车符的字符。</li>
<li>std::endl 是流操纵符(manipulator)，输出的作用和输出''类似，其效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容冲刷(flush)到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。 <a id="more"></a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>等价于 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br></pre></td></tr></table></figure> 对于有输出缓冲的流(例如cout、clog)，如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于cout来说(相对于文件输出流等)，缓冲一般体现得并不明显。但是必要情况下使用endl代替''一般是个好习惯。 对于无缓冲的流(例如标准错误输出流cerr)，刷新是不必要的，可以直接使用 ''，过多的endl会影响程序的执行效率。</p>
<h3 id="说明指针和引用的区别">说明指针和引用的区别</h3>
<ul>
<li>引用是另一个对象的别名，而指针本身就是一个对象。</li>
<li>引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。</li>
</ul>
<h3 id="常量指针和常量引用有什么不同">常量指针和常量引用有什么不同？</h3>
<p>常量指针（const pointer）是常量化的指针是正规翻译，常量引用（reference to const）是对常量的引用是坊间俗称。</p>
<h3 id="说明decltype和auto的区别">说明decltype和auto的区别</h3>
<p>auto: 类型说明符，用它能让编译器代替我们去分析表达式所属的类型。auto定义的变量必须有初始值，auto在一条语句中声明多个变量必须保证同样的基本数据类型。</p>
<p>decltype: 类型指示符，为了从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。</p>
<ol type="1">
<li><p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>不同，<code>auto</code> 会忽略顶层const和直接推演引用所指的类型，<code>decltype</code>会将顶层<code>const</code>和引用保留起来。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x1 = <span class="number">0</span>;   <span class="comment">// x1的类型是const int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = ci;          <span class="comment">// x2的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y1 = x;   <span class="comment">// y1的类型是const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> y2 = cj;          <span class="comment">// y2的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> y3 = &amp;cj;		   <span class="comment">// y3的类型是const int*，取值算底层const会保留</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>decltype</code>处理（对指针）解引用操作得到引用类型，而<code>auto</code>得到指针所指对象的类型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, *p = &amp;i;		</span><br><span class="line"><span class="keyword">decltype</span>(*p) pr = i;	<span class="comment">// pr的类型是int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> pa = *p;			<span class="comment">// pa的类型是int</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>decltype</code>结果类型与表达式形式密切相关</p></li>
</ol>
<p>如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会将把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的<code>decltype</code>就会的得到引用类型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((a)) d=a; <span class="comment">// d的类型为int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(a)   d2;  <span class="comment">// d2的类型为未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>(a=b) d3=b; <span class="comment">// d3的类型为int &amp;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 变量与基本类型</title>
    <url>/2020/06/28/C++%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>《C++ Primer（第五版）》第二章笔记 ## 基本内置类型</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr class="even">
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr class="odd">
<td>wchar_t</td>
<td>宽字符</td>
<td>16位</td>
</tr>
<tr class="even">
<td>char16_t</td>
<td>Unicode 字符</td>
<td>16位</td>
</tr>
<tr class="odd">
<td>char32_t</td>
<td>Unicode 字符</td>
<td>32位</td>
</tr>
<tr class="even">
<td>short</td>
<td>短整型</td>
<td>16位</td>
</tr>
<tr class="odd">
<td>int</td>
<td>整型</td>
<td>16位</td>
</tr>
<tr class="even">
<td>long</td>
<td>长整型</td>
<td>32位</td>
</tr>
<tr class="odd">
<td>long long</td>
<td>长整型</td>
<td>64位</td>
</tr>
<tr class="even">
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr class="odd">
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr class="even">
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody>
</table>
<p>可寻址最小内存块称为字节(Byte)，存储的基本单元称为字(Word)。在一台32位的计算机上，32位即字长。 <a id="more"></a></p>
<ul>
<li>一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long之上和一个long一样大</li>
<li>float 以1个字来表示，double用2个字来表示，long double以3或4个字来表示</li>
</ul>
<blockquote>
<p>如何选择类型：</p>
<ol type="1">
<li>当明确知晓数值不可能为负时，选用无符号类型。</li>
<li>使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。</li>
<li>在算数表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。原因在于char类型在一些机器上是有符号的，而在另一些机器上又是无符号的。<u>如果你需要使用一个不大的整数，那么明确指定它的类型是signed char还是unsigned char</u>。比如一些数字char的操作。</li>
<li>执行浮点数运算选用double，这是因为floa通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。</li>
</ol>
</blockquote>
<h4 id="类型转换">类型转换</h4>
<ul>
<li>当我们赋予无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</li>
<li>当我们赋予<strong>带符号</strong>一个超出它表示范围的值时，结果是<strong>未定义的</strong>。</li>
<li>当一个算数表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。</li>
</ul>
<h4 id="字面值常量literal">字面值常量(literal)</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 &#x2F;* 十进制 *&#x2F;</span><br><span class="line">024 &#x2F;* 八进制 *&#x2F;</span><br><span class="line">0x14 &#x2F;* 十六进制 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>转义序列：<code>‘\’</code>后跟八进制数字，<code>\x</code>后跟十六进制数字转义字符。如果反斜线<code>\</code>后面跟着的数字超过3个，只有前3个数字构成转义序列<code>u8"\1234"="S4"</code>。</p>
<p>指定字面值类型（整型和浮点型）：</p>
<table>
<thead>
<tr class="header">
<th>后缀</th>
<th>最小匹配类型</th>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u/U</td>
<td>unsigned</td>
<td>f/F</td>
<td>float</td>
</tr>
<tr class="even">
<td>l/L</td>
<td>long</td>
<td>l/L</td>
<td>long double</td>
</tr>
<tr class="odd">
<td>ll/LL</td>
<td>long long</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="变量">变量</h2>
<p><code>对象(object)</code>: 一块能存储数据并具有某种类型的内存空间</p>
<h3 id="初始化">初始化</h3>
<p>初始化不是赋值，初始化的含义式创建变量时赋予其一个初始值，而赋值的含义式把对象的当前值擦除，而以一个新值来替代。</p>
<h4 id="默认初始化">默认初始化</h4>
<p>如果内置类型的变量未被显式初始化，它的值由定义的位置决定。定义域仍和函数体之外的变量被初始化为0，而定义在函数体内部的内置类型变量将<strong>不被初始化</strong>。一个未被初始化的内置类型变量的值式未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<blockquote>
<p>未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为且很难调试。</p>
</blockquote>
<h3 id="变量声明和定义的关系">变量声明和定义的关系</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明i而非定义i</span></span><br><span class="line"><span class="keyword">int</span> j;  <span class="comment">// 声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong></p>
<p>声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h3 id="标识符">标识符</h3>
<p>C++的标识符(identifier)由字母、数字和下划线组成，其中必须以字母或下划线开头。</p>
<ul>
<li>用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头</li>
<li>函数体外的标识符不能以下划线开头</li>
</ul>
<h3 id="作用域">作用域</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 函数内部不宜定义与全局变量名同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::count &lt;&lt; reused &lt;&lt; <span class="string">" "</span> &lt;&lt; unique &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出#1：使用全局变量reused；输出 42 0</span></span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>;<span class="comment">// 新建局部变量reused，覆盖了全局变量reused</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="string">" "</span> &lt;&lt; unqiue &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出#2：使用局部变量reused; 输出 0 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::reused &lt;&lt; <span class="string">" "</span> &lt;&lt; unique &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出#3: 显式地访问全局变量reused; 输出 42 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复合类型">复合类型</h2>
<h3 id="引用">引用</h3>
<ol type="1">
<li>引用并非对象二十为一个就已经存在地对象所起的别名</li>
<li>不能定义引用的引用</li>
<li>引用只能绑定在对象上，而不能与<strong>字面值</strong>或<strong>某个表达式</strong>的计算结果绑定在一起(除非是常量引用)</li>
<li>必须初始化</li>
<li>一旦引用完成初始化，该引用将无法重新绑定到另外一个对象上</li>
</ol>
<h3 id="指针">指针</h3>
<ol type="1">
<li>指针本身是一个对象，允许对指针赋值和拷贝</li>
<li>指针无需在定义时赋值</li>
<li>指针存放某个对象的地址，需要使用<strong>取地址符&amp;</strong></li>
<li>引用不是对象，没有实际地址，所以不能定义指向引用的指针</li>
<li><code>*p</code>解引用符访问对象，解引用符仅适合于那些确实指向了某个对象的有效指针</li>
</ol>
<p>空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检擦它是否为空。一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">//等价于int *p1 = 0;</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>; <span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="comment">// 需要首先#include cstdlib</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">// 等价于 int *p3 = 0; 尽量使用 nullptr</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议：初始化所有指针。在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。</p>
</blockquote>
<h4 id="void-指针">void* 指针</h4>
<p><strong>void</strong><em>是一种特殊的指针类型，可用于存放任意对象的地址。然而对于 <strong>void</strong></em>来说，内存空间仅仅是内存空间，没办法访问内存空间中所存的对象。(对void*指针使用解引用符<code>*</code>会报错)</p>
<h4 id="理解复合指针的声明">理解复合指针的声明</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">// pi 指向一个int类型的数</span></span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi; <span class="comment">// ppi 指向一个int类型的指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r = pi;  <span class="comment">// r 一个对整型指针pi的引用</span></span><br></pre></td></tr></table></figure>
<p>以上可以改写为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>, *pi=&amp;ival, **ppi=&amp;pi, *&amp;r=pi;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>面对一条比较复杂的声明语句时，从右向左读，离变量名最近的符号对变量的类型右最直接的影响。</p>
</blockquote>
<h2 id="const-限定符">const 限定符</h2>
<p>const大法：</p>
<ol type="1">
<li>const对象一旦创建后其值就不能再改变，所以const对象必须初始化</li>
<li>如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要</li>
<li>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字</li>
</ol>
<h3 id="const引用">const引用</h3>
<p><code>常量引用</code>: 对const常量的引用，不能被用作修改它所绑定的对象</p>
<p>常量引用初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;		<span class="comment">// 正确 不必在意对象是否为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;		<span class="comment">// 正确 允许字面值</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2_ = <span class="number">42</span>;			<span class="comment">// 错误 非常量引用不允许字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;	<span class="comment">// 正确 允许表达式 </span></span><br><span class="line"><span class="keyword">int</span> &amp;r3_ = r1 * <span class="number">2</span>;		<span class="comment">// 错误 非常量引用不允许表达式结果</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> &amp;dr1 = i;	<span class="comment">// 正确 允许数据类型隐性转换</span></span><br><span class="line"><span class="keyword">double</span> &amp;dr2 = i;		<span class="comment">// 错误 非常量引用必须和对象数据类型一致</span></span><br></pre></td></tr></table></figure>
<p><em>为啥C++这样设计？</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<p>编译器把上述代码变成如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>
<p>如果<span class="math inline">\(ri\)</span>不是常量引用，就允许对<span class="math inline">\(ri\)</span>赋值，并且丢弃精度，这样会改变<span class="math inline">\(ri\)</span>所引用对象的值。否则，我们绑定的对象就是一个临时量而非dval。我们既然用ri引用dval，就肯定想通过ri改变dval的值，否则干什么个ri赋值呢？既然大家不会想着把引用绑定到临时量上，C++也就把这种行为归为非法。</p>
<p>常量引用值对引用做限制而对引用的对象是否为常量不做限制。</p>
<h3 id="指针和const">指针和const</h3>
<p><code>指向常量的指针</code>: 令指针指向常量，存放常量对象的地址。</p>
<p><strong>允许一个指向常量的指针指向一个非常量对象（普通指针不允许）</strong></p>
<p><code>常量指针</code>: const pointer，必须初始化，而且一旦初始化完成，则它的值（存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<h3 id="顶层const">顶层const</h3>
<p><code>顶层const</code>: (top-level const) 表示指针本身是个常量；表示任意对象都可以是一个常量。</p>
<p><code>底层const</code>: (low-level const) 表示指针所指的对象是一个常量；表示所指对象是常量像引用和指针。</p>
<p><strong>只有指针既可以是顶层const也可以是底层const</strong></p>
<h4 id="拷贝操作">拷贝操作</h4>
<ul>
<li><p>顶层const不受拷贝操作影响</p></li>
<li><p>而底层从上图的拷贝需要拷入和拷出的对象必须具有相同的底层const的资格，或者两个对象的数据类型必须能够转换。非常量可以转换成常量，反之则不行。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = ci; <span class="comment">// 错误：普通指针不能绑定到int常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i; <span class="comment">// 正确： 常量引用可以绑定到普通int上</span></span><br></pre></td></tr></table></figure>
<h3 id="常量表达式">常量表达式</h3>
<p>常量表达式是指值不会改变并且在<strong>编译过程</strong>就能得到计算结果的表达式。比如，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size(); <span class="comment">// sz 不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。申明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;  <span class="comment">// mf+1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">// 只有当size是一个constexpr函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>
<p>如果在constexpr声明中是一个指针，那constexpr支队指针有效：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;		<span class="comment">// p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h2 id="处理类型">处理类型</h2>
<h3 id="类型别名">类型别名</h3>
<p>两种方法定义类型别名，一是typedef，二是using。</p>
<h4 id="typedef">typedef</h4>
<p>定义类别别名，让复杂的类型名字变得简单明了、简单易用（更复杂（雾））。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>
<h4 id="using">using</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure>
<p>这样声明别名后就可以用别名来定义对象了。</p>
<h4 id="指针常量和类别别名">指针、常量和类别别名</h4>
<p><code>typedef</code>就是晦涩难懂的代名词</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;	<span class="comment">// 为指向char的指针做别名</span></span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr是一个指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;		<span class="comment">// ps是一个指向 指向char的常量指针 的指针 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cst = <span class="number">0</span>;   <span class="comment">// 是一个指向常量char的普通指针</span></span><br></pre></td></tr></table></figure>
<h4 id="auto和decltype">auto和decltype</h4>
<p>auto: 类型说明符，用它能让编译器代替我们去分析表达式所属的类型。auto定义的变量必须有初始值，auto在一条语句中声明多个变量必须保证同样的基本数据类型。</p>
<p>decltype: 类型指示符，为了从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。</p>
<ol type="1">
<li><p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>不同，<code>auto</code> 会忽略顶层const和直接推演引用所指的类型，<code>decltype</code>会将顶层<code>const</code>和引用保留起来。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x1 = <span class="number">0</span>;   <span class="comment">// x1的类型是const int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = ci;          <span class="comment">// x2的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y1 = x;   <span class="comment">// y1的类型是const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> y2 = cj;          <span class="comment">// y2的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> y3 = &amp;cj;		   <span class="comment">// y3的类型是const int*，取值算底层const会保留</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>decltype</code>处理（对指针）解引用操作得到引用类型，而<code>auto</code>得到指针所指对象的类型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, *p = &amp;i;		</span><br><span class="line"><span class="keyword">decltype</span>(*p) pr = i;	<span class="comment">// pr的类型是int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> pa = *p;			<span class="comment">// pa的类型是int</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>decltype</code>结果类型与表达式形式密切相关</p></li>
</ol>
<p>如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会将把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的<code>decltype</code>就会的得到引用类型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((a)) d=a; <span class="comment">// d的类型为int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(a)   d2;  <span class="comment">// d2的类型为未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>(a=b) d3=b; <span class="comment">// d3的类型为int &amp;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义数据结构">自定义数据结构</h2>
<p><code>struct</code>：通篇只讲这个。</p>
<ul>
<li>类内定义的名字必须唯一，但是可以和类外部定义的名字重复</li>
<li>类体右侧的表示结束的花括号必须写一个分号，这是因为类体后面可以紧跟变量名以实对该类型对象的定义（但是不推荐这样做）</li>
<li>类内允许有<strong>类内初始值</strong>来初始化类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span><span class="comment">/*...*/</span>&#125; accum, trans, *sp;</span><br><span class="line"><span class="comment">/* &lt;==&gt; */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_Data</span> &#123;</span><span class="comment">/*...*/</span>&#125;;</span><br><span class="line">Sales_data accum, trans, *sp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说最好不要把对象的定义和类的定义放在一起。这样做无异于把两种不同实体的定义混在了一条语句离，一会儿类，一会儿变量，非常不合适。</p>
</blockquote>
<h4 id="头文件保护符">头文件保护符</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>SALES_DATA_H</strong>为头文件保护符，如此的预处理变量必须唯一，通常的做法是基于头文件的名字来构建保护符的名字。</p>
<p><code>#defube</code>: 把一个名字设定为预处理变量</p>
<p><code>#ifdef</code>: 当且仅当变量已定义为真</p>
<p><code>#ifndef</code>: 当且仅当变量未定义为真</p>
<p>一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>为止。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>language</tag>
        <tag>CppPrimer</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题集</title>
    <url>/2020/06/02/DP/</url>
    <content><![CDATA[<!-- # 动态规划 -->
<h4 id="最长回文子串"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4>
<p>这题能在面试中做出来的有三种方法<br> 1. 暴力 <span class="math inline">\(O(n^3)\)</span> 2. 动态规划 <span class="math inline">\(O(n^2)\)</span> 3. 中心扩展 <span class="math inline">\(O(n^2)\)</span> <a id="more"></a></p>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> length &lt;= n:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                j = i + length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> length == <span class="number">2</span>:</span><br><span class="line">                    dp[i][j] = int(s[i] == s[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = int(dp[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> s[i] == s[j])</span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> length &gt; len(ret):</span><br><span class="line">                    ret = s[i:j+<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>状态定义:</p>
<p>dp[i][j]表示字符串从i到j，包括j，是否为回文字符串</p>
<p>状态转移方程： <span class="math display">\[
dp[i][j]=
\begin{cases}
1 &amp; dp[i+1][j-1] == 1\ and \ s[i]==s[j] \\
0 &amp; \ otherwise
\end{cases}
\]</span> 难点1：如何遍历dp二维数组比较恰当。这里我们用子字符串长度<span class="math inline">\(length\)</span>来表示<span class="math inline">\(j\)</span>, <span class="math inline">\(j=i+length-1\)</span>, 由此我们可以实现二维数组对角线遍历而不会重复。</p>
<p>边界点1：<span class="math inline">\(s\)</span>为空字符，我们在设置返回项时应该设置空字符（如果不提前规避的话）表示最长的回文字符串为空，长度为1。</p>
<p>边界点2：单字符，双字符，皆为该dp的边界点。我们应该首先计算出这些边界点的状态。可以在遍历大遍历之前小遍历初始化，也可以在整个遍历里设置单独条件计算这些边界点的状态。</p>
<p>边界点3：<span class="math inline">\(j\)</span>越界，只要保证<span class="math inline">\(j\)</span>不越界，那么<span class="math inline">\(i+1\)</span>肯定也不越界。</p>
<h5 id="中心扩展">中心扩展</h5>
<p>其实个人觉得，比起dp，中心扩展法更少边界值，更容易上手。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        left, right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left1, right1 = self.centerExpand(s, i, i)</span><br><span class="line">            left2, right2 = self.centerExpand(s, i, i+<span class="number">1</span>)</span><br><span class="line">            l, r = (left1, right1) <span class="keyword">if</span> right1-left1 &gt; right2-left2 <span class="keyword">else</span> (left2, right2)</span><br><span class="line">            left, right = (left, right) <span class="keyword">if</span> right-left &gt; r-l <span class="keyword">else</span> (l, r)</span><br><span class="line">        <span class="keyword">return</span> s[left:right+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">centerExpand</span><span class="params">(self, s, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= i <span class="keyword">and</span> j &lt; len(s) <span class="keyword">and</span> s[i]==s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>, j<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>中心扩展法其实就是利用边界点（单字符和双字符）去扩展得到所有的回文子串。</p>
<p>难点1：中心扩展函数的写法。一开始我用递归，有点麻烦，容易出错。后来看官方答案，这玩意要啥递归，while loop就完事了。</p>
<p>边界点：其实只要中心扩展函数写得好，基本不用考虑边界点。像上方官答，双字符是不相等和第二个字符越界的条件都不用考虑。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题(上)</title>
    <url>/2020/06/02/Knapsack1/</url>
    <content><![CDATA[<p>此博客根据<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf" target="_blank" rel="noopener">背包九讲</a>1-3章整理编写而成，记录学习总结。</p>
<h2 id="背包问题">0-1背包问题</h2>
<h3 id="题目">题目</h3>
<p>有 <span class="math inline">\(N\)</span> 件物品和一个容量为 <span class="math inline">\(V\)</span> 的背包。放入第 <span class="math inline">\(i\)</span> 件物品耗费的费用是 <span class="math inline">\(C_i\)</span> 价值是 <span class="math inline">\(W_i\)</span>。求解将哪些物品装入背包可使价值总和最大。</p>
<h3 id="思路">思路</h3>
<p>定义子问题状态: <span class="math inline">\(F[i,v]\)</span>为前<span class="math inline">\(i\)</span>件物品放入一个容量为<span class="math inline">\(v\)</span>的背包可以获得的最大价值。这里的前<span class="math inline">\(i\)</span>件物品包括第<span class="math inline">\(i\)</span>件物品。 状态转移方程： <span class="math display">\[
F[i,v]=\max\{F[i-1,v], F[i-1,v-C_i]+W_i\}
\]</span> <a id="more"></a> 这个状态转移方程非常好理解，对于第<span class="math inline">\(i\)</span>件物品，我们只有放与不放两种选项，如果不放，那么这个背包的价值就是和前<span class="math inline">\(i-1\)</span>件物品放入背包的价值一样，即<span class="math inline">\(F[i-1,v]\)</span>；如果放的话，那么这个背包的价值就是前<span class="math inline">\(i-1\)</span>件物品放入容量为<span class="math inline">\(v-C_i\)</span>的背包的价值再加上当前物品的价值<span class="math inline">\(W_i\)</span>。 接下来的问题就是如何填充这个二维数组<span class="math inline">\(F_{N\times V}\)</span>。首先我们要看到，由于我们根本不清楚这个<span class="math inline">\(V\)</span>有多大，<span class="math inline">\(C\)</span>里面有哪些数，所以我们在迭代时一定要保证<span class="math inline">\(F[i-1]\)</span>里所有的entry都是已知的，也就是前<span class="math inline">\(i\)</span>件物品在所有可能的背包容量下的价值。 伪代码： <img src="/2020/06/02/Knapsack1/image-20200527112309894.png" class="" title="pseudocode_01"> 代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ZeroOnePackBasic</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    Vs = V + <span class="number">1</span></span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (Vs) <span class="keyword">for</span> _ <span class="keyword">in</span> range(Ns)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(C[i<span class="number">-1</span>], Vs):</span><br><span class="line">            dp[i][v] = max(dp[i<span class="number">-1</span>][v], dp[i<span class="number">-1</span>][v-C[i<span class="number">-1</span>]]+W[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[N][V]</span><br></pre></td></tr></table></figure>
<p>边界点1：<span class="math inline">\(v=0,i=0\)</span>, 虽然我们的容量为<span class="math inline">\(V\)</span>，物品数目为<span class="math inline">\(N\)</span>，但我们有<span class="math inline">\(V+1\)</span>，<span class="math inline">\(N+1\)</span>种物品（包含0容量和前0件物品）。</p>
<p>边界点2：<span class="math inline">\(v&lt;C_i\)</span>，易知当v小于<span class="math inline">\(C_i\)</span>时，根本无法将第<span class="math inline">\(i\)</span>件物品放入背包，所以我们的遍历空间为<span class="math inline">\(C_i...V\)</span>。</p>
<h3 id="优化空间复杂度">优化空间复杂度</h3>
<p>实用一个数组<span class="math inline">\(F[0...V]\)</span>来代替二维数组，原因在于状态转移方程只和上一次迭代的结果，也就是<span class="math inline">\(F[i-1, 0...V]\)</span>相关。所以我们可以基于上一个<span class="math inline">\(F_{i-1}\)</span>来更新当前<span class="math inline">\(F_i\)</span>。然而，我们必须逆序计算<span class="math inline">\(F[v]\)</span>, <span class="math inline">\(v \leftarrow V...0\)</span>，原因在于这样可以保证<span class="math inline">\(v-C_i\)</span>之前的entry是<span class="math inline">\(F_{i-1}\)</span>未更新的。</p>
<p>伪代码：</p>
<img src="/2020/06/02/Knapsack1/image-20200527132900818.png" class="" title="pseudocode_01">
<p>代码实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ZeroOnePackOpt</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    Vs = V + <span class="number">1</span></span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * Vs</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(Vs<span class="number">-1</span>, C[i<span class="number">-1</span>]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = max(dp[v], dp[v-C[i<span class="number">-1</span>]]+W[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[V]</span><br></pre></td></tr></table></figure>
<h3 id="题目变种">题目变种</h3>
<p>要求==恰好装满背包==时的最优解。</p>
<p>这种情况我们要重新定义一下子问题状态: <span class="math inline">\(F[i,v]\)</span>为前<span class="math inline">\(i\)</span>件物品放入一个容量为<span class="math inline">\(v\)</span>的背包<em>恰好装满</em>时可以获得的最大价值。这里的前<span class="math inline">\(i\)</span>件物品包括第<span class="math inline">\(i\)</span>件物品。</p>
<p>也就是说我们初始化的时候需要重新定义<span class="math inline">\(F\)</span>的合法数值，当<span class="math inline">\(i=0\)</span>，只有<span class="math inline">\(v=0\)</span>，才能满足恰好装满的条件，也就是没有任何物品放入背包，背包已满。<span class="math inline">\(v\)</span>的其他取值都初始化为<span class="math inline">\(-\infty\)</span>，也就是标记为不合法。</p>
<p>代码实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ZeroOnePackFull</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    Vs = V + <span class="number">1</span></span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [float(<span class="string">'-inf'</span>)] * Vs</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(Vs<span class="number">-1</span>, C[i<span class="number">-1</span>]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = max(dp[v], dp[v-C[i<span class="number">-1</span>]]+W[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[V]</span><br></pre></td></tr></table></figure>
<h3 id="复杂度">复杂度</h3>
<p>时间复杂度为<span class="math inline">\(O(VN)\)</span></p>
<p>优化后的空间复杂度为<span class="math inline">\(O(V)\)</span></p>
<h2 id="完全背包问题">完全背包问题</h2>
<h3 id="题目-1">题目</h3>
<p>有<span class="math inline">\(N\)</span>种物品和一个容量为<span class="math inline">\(V\)</span>的背包，每种物品都有无限件可用。放入第<span class="math inline">\(i\)</span>种物品的费用是<span class="math inline">\(C_i\)</span>价值是<span class="math inline">\(W_i\)</span>。求解：将哪些物品装入背包，可以使得这些物品的耗费的费用总和不超过背包容量，且价值总和最大。</p>
<h3 id="基本思路">基本思路</h3>
<p>这个问题非常类似于0-1背包问题，所不同的是每种物品都有无限件。所以每种物品的取件数有<span class="math inline">\(\lfloor V/C_i \rfloor\)</span>种选择。</p>
<p>现在我们仍旧定义原来的子问题<span class="math inline">\(F[i,v]\)</span>，只不过加上了可以重复取件的条件。</p>
<p>于是乎状态转移方程需要发生改变: <span class="math display">\[
F[i,v]=\max\{F[i-1,v-kC_i]+kW_i | 0 \leq kC_i \leq v\}
\]</span> 这个和0-1背包问题一样有<span class="math inline">\(O(VN)\)</span>个状态需要求解，但是求解每个状态的时间不是常数而是<span class="math inline">\(O(\lfloor \frac{v}{C_i}\rfloor)\)</span>，总的时间复杂度为<span class="math inline">\(O(NV\sum^N_{i=1}{\frac{V}{C_i}})\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CompletePackBasic</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    Vs = V + <span class="number">1</span></span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * Vs</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(Vs<span class="number">-1</span>, C[i<span class="number">-1</span>]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, (v // C[i<span class="number">-1</span>])+<span class="number">1</span>):</span><br><span class="line">                tmp.append(dp[v-k*C[i<span class="number">-1</span>]]+k*W[i<span class="number">-1</span>])</span><br><span class="line">            dp[v] = max(tmp)</span><br><span class="line">    <span class="keyword">return</span> dp[V]</span><br></pre></td></tr></table></figure>
<h3 id="优化">优化</h3>
<h4 id="优化1-对数据进行预处理">优化1 对数据进行预处理：</h4>
<p>首先将费用大于 V 的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以差不多用<span class="math inline">\(O(V +N)\)</span>地完成这个优化，除非重复费用的物品过多。</p>
<h4 id="优化2-转化为01背包问题">优化2 转化为01背包问题：</h4>
<p>这个优化非常刁钻，考虑到第<span class="math inline">\(i\)</span>种物品最多选 <span class="math inline">\(⌊V/C_i⌋\)</span> 件，于是可以把第<span class="math inline">\(i\)</span>种物品转化为<span class="math inline">\(⌊V/C_i⌋\)</span>件费用及价值均不变的物品。比如现有 <span class="math display">\[
\begin{equation} \nonumber
\begin{aligned}
N &amp;= 4  \\ 
V &amp;= 10 \\ 
C &amp;= [10, 6, 3, 4]  \\ 
W &amp;= [10, 7, 6, 5] \\ 
\end{aligned} 
\end{equation}
\]</span> 我们可以将其转换为如下的0-1背包问题 <span class="math display">\[
\begin{aligned}
N &amp;= 7 \\
V &amp;=10 \\
C &amp;= [10,6,3,3,3,4,4] \\
W &amp;= [10,7,6,6,6,5,5] \\
\end{aligned}
\]</span> 还有一种更骚的操作是：把第<span class="math inline">\(i\)</span>种物品拆成费用为<span class="math inline">\(C_i2^k\)</span>、价值为<span class="math inline">\(W_i2^k\)</span>的若干件物品，其中<span class="math inline">\(k\)</span>取遍满足<span class="math inline">\(C_i2^k≤V\)</span>的非负整数。不管最优策略选几件第$i $种物品，总可以表示成若干个不同<span class="math inline">\(2^k\)</span>物品的和。这样一来就把每种物品拆成<span class="math inline">\(O(\log ⌊V/Ci⌋)\)</span>件物品，是一个很大的改进。用之前的例子，我们可以将其装化为如下的01背包问题 <span class="math display">\[
\begin{aligned}
N &amp;= 6 \\
V &amp;= 10 \\
C &amp;= [10, 6, 3, 6, 4,8] \\
W &amp;= [10, 7, 6, 12,5,10] \\
\end{aligned}
\]</span> 为什么可以如此转换呢？原因在于<span class="math inline">\(2^n-1=\sum_{i=0}^{n-1}2^{i}\)</span>，我们可以看到在上一个简单的01背包问题转换操作中，取3个费用为3价值为6的情况是用3个相同价值相同费用的物品实现的，而在这个转换方法中这种情况是由取1个费用为3和1个费用为6的物品实现的，大大减少了遍历的次数。</p>
<h4 id="优化3-ovn-改变遍历次序">优化3 O(VN) 改变遍历次序</h4>
<p>伪代码：</p>
<img src="/2020/06/02/Knapsack1/image-20200527163346518.png" class="" title="pseudocode_03">
<p>我们可以发现，这段伪代码和01背包问题仅仅只有<span class="math inline">\(v\)</span>的循环次序不同，现在采用增序递增的方式更新子状态。原因在于，此时我们需要一个可能已选入第<span class="math inline">\(i\)</span>种物品的子结果<span class="math inline">\(F[i,v-C_i]\)</span>。此时的状态转移方程为: <span class="math display">\[
F[i,v]=\max\{F[i-1,v],F[i,v-C_i]+W_i\}
\]</span> <span class="math inline">\(F[i-1,v]\)</span>：不放入第<span class="math inline">\(i\)</span>件物品</p>
<p><span class="math inline">\(F[i,v-C_i]\)</span>: 上一次放了第<span class="math inline">\(i\)</span>件物品时的价值加上这次放第<span class="math inline">\(i\)</span>件物品</p>
<p>此时的空间复杂度为<span class="math inline">\(O(V)\)</span>，时间复杂度依然为<span class="math inline">\(O(VN)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CompletePackVN</span><span class="params">(N, V, C, W)</span>:</span></span><br><span class="line">    Vs = V + <span class="number">1</span></span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * Vs</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(C[i<span class="number">-1</span>], Vs):</span><br><span class="line">            dp[v] = max(dp[v], dp[v-C[i<span class="number">-1</span>]]+W[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[V]</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题">多重背包问题</h2>
<h3 id="题目-2">题目</h3>
<p>有<span class="math inline">\(N\)</span>种物品和一个容量为<span class="math inline">\(V\)</span>的背包。第<span class="math inline">\(i\)</span>种物品最多有<span class="math inline">\(M_i\)</span>件可用，每件耗费的空间是<span class="math inline">\(C_i\)</span>，价值是<span class="math inline">\(W_i\)</span>。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
<h3 id="基本思路-1">基本思路</h3>
<p>这题和完全背包问题十分相似，在这里对于第<span class="math inline">\(i\)</span>种物品，我们有<span class="math inline">\(M_i+1\)</span>种策略：取0件，取1件，....，取<span class="math inline">\(M_i\)</span>件；而在完全背包问题种我们有<span class="math inline">\(\lfloor \frac{V}{C_i}\rfloor +1\)</span>种取法。所以我们只要稍微修改一下状态转移方程即可： <span class="math display">\[
F[i,v]=\max\{F[i-1,v-k*C_i]+k*W_i|0\leq k \leq M_i\}
\]</span> 此时的时间复杂的为<span class="math inline">\(O(V\sum_{i=1}^{N}M_i)\)</span>。</p>
<h3 id="转化为01背包问题">转化为01背包问题</h3>
<p>和之前的完全背包问题一样，多重背包问题也可以通过拆分转换为01背包问题。</p>
<p>如完全背包问题中的<strong>优化1</strong>一样，我们可以将第<span class="math inline">\(i\)</span>种物品拆分成<span class="math inline">\(M_i\)</span>件相同费用相投价值的物品。此时的时间复杂度依然是<span class="math inline">\(O(V\sum_{i=1}^{N}M_i)\)</span>。</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiPackBasic</span><span class="params">(N, V, C, W, M)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将多重背包问题简单转换成01背包问题</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        m = M[i] - <span class="number">1</span></span><br><span class="line">        C += [C[i]] * m</span><br><span class="line">        W += [W[i]] * m</span><br><span class="line">        N += m</span><br><span class="line">    Vs = V + <span class="number">1</span> </span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * Vs</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(Vs<span class="number">-1</span>, C[i<span class="number">-1</span>]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = max(dp[v], dp[v-C[i<span class="number">-1</span>]]+W[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>同样的，我们还可按照之前<strong>优化1</strong>中的第二种方法来拆分：</p>
<p>将第<span class="math inline">\(i\)</span>种物品拆分成若干个01背包中的物品，这些物品的费用和价值均是原来的费用和价值乘以这个系数。这些系数分别为<span class="math inline">\(1,2,..,2^k\)</span>且<span class="math inline">\(k\)</span>是满足<span class="math inline">\(2^k\leq M_i\)</span>的最大整数。例如，如果<span class="math inline">\(M_i\)</span>为<span class="math inline">\(13\)</span>，则相应的<span class="math inline">\(k = 3\)</span>，这种最多取<span class="math inline">\(13\)</span>件的物品应被分成系数分别为<span class="math inline">\(1, 2, 4, 8\)</span>的四件物品。</p>
<blockquote>
<p>为什么我这里采用的系数和背包九讲里的系数不同？因为我按照的是之前完全背包问题的拆分方法，也就是拆到系数大到允许的物品件数为止。个人认为，这样的拆分方法更容易理解，也更容易实现和证明。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiPackBinary</span><span class="params">(N, V, C, W, M)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将多重背包问题利用二进制的特性转换成01背包问题</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        Mi = M[i]</span><br><span class="line">        k = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= Mi:</span><br><span class="line">            N += <span class="number">1</span></span><br><span class="line">            W += [W[i] * k]</span><br><span class="line">            C += [C[i] * k]</span><br><span class="line">            k *= <span class="number">2</span></span><br><span class="line">    Vs = V + <span class="number">1</span> </span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * Vs</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(Vs<span class="number">-1</span>, C[i<span class="number">-1</span>]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[v] = max(dp[v], dp[v-C[i<span class="number">-1</span>]]+W[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(V\sum_{i=1}^{N}\log{M_i})\)</span>；空间复杂度：<span class="math inline">\(O(V)\)</span> （我们可以筛掉不可能的取件数选项）。</p>
<h4 id="二进制拆分法的数学证明">二进制拆分法的数学证明</h4>
<p><em>本证明由某复旦数学系大佬提供</em></p>
<p><span class="math inline">\(Proposition\)</span>: For any positive integer <span class="math inline">\(m \leq 2^{n}-1\)</span>，there exists a set <span class="math inline">\(S \subseteq \{0,1,2,...,n-1\}\)</span> and <span class="math inline">\(S\neq \phi\)</span> such that <span class="math inline">\(m=\sum_{i\in S}2^{i}\)</span>.</p>
<p><span class="math inline">\(Proof\)</span>:</p>
<p>It is obvious to get there are totally <span class="math inline">\(2^n-1\)</span> kinds of <span class="math inline">\(S\)</span>, because the number of permutations is <span class="math display">\[
\sum_{i=1}^n{n \choose i}=2^n-1
\]</span> Also, we can find the maximum of <span class="math inline">\(m\)</span> is <span class="math inline">\(2^n - 1\)</span> and the minimum is <span class="math inline">\(1\)</span>. There are totally <span class="math inline">\(2^n-1\)</span>, and the range of the sum is from <span class="math inline">\(1\)</span> to <span class="math inline">\(2^n-1\)</span>. It means that as long as we prove the sum of each <span class="math inline">\(S\)</span> is unique, we can prove the proposition. In mathematical words, for any <span class="math inline">\(S_i,S_j\)</span> where <span class="math inline">\(i\neq j\)</span>, <span class="math inline">\(\sum_{k\in S_i}2^k \neq \sum_{k \in S_j}2^k\)</span>.</p>
<p>Given two different sets <span class="math inline">\(S_i\)</span> and <span class="math inline">\(S_j\)</span>, we can get <span class="math inline">\(G_i = S_i-S_j\)</span> and <span class="math inline">\(G_j=S_j-S_i\)</span>. WLOG, we only need to prove that <span class="math inline">\(\sum_{k\in G_i}2^k \neq \sum_{k \in G_j}2^k\)</span>, for any <span class="math inline">\(G_i,G_j\)</span> where <span class="math inline">\(i\neq j\)</span>.</p>
<p>First situation, either <span class="math inline">\(G_i\)</span> or <span class="math inline">\(G_j\)</span> contains the index <span class="math inline">\(0\)</span>. WLOG, we assume <span class="math inline">\(G_i\)</span> contains the index <span class="math inline">\(0\)</span>. Then the component sum of <span class="math inline">\(G_i\)</span> is odd, while the component of <span class="math inline">\(G_j\)</span> is even. Therefore, they must be different.</p>
<p><span class="math display">\[
\sum_{k \in G_i}{2^k}=1+\sum_{k\neq 0, k \in G_i}{2^k} \neq \sum_{k\in G_j}2^k
\]</span> Second situation, neither <span class="math inline">\(G_i\)</span> or <span class="math inline">\(G_j\)</span> contains the index 0. We defined that <span class="math inline">\(G_i=\{2^{i_k}|i_k&lt;i_{k+1},k=1,2,...,p\}\)</span> where <span class="math inline">\(p\)</span> is the number of entries in <span class="math inline">\(G_i\)</span>, similarly, <span class="math inline">\(G_j=\{2^{j_k}|j_k&lt;j_{k+1},k=1,2,...,q\}\)</span> where <span class="math inline">\(q\)</span> is the number of entries in <span class="math inline">\(G_j\)</span>. WLOG, we set <span class="math inline">\(i_1 &lt; j_1\)</span>.</p>
<p>We assume that the internal summations of <span class="math inline">\(G_i\)</span> and <span class="math inline">\(G_j\)</span> are equal, we can get the following equation: <span class="math display">\[
\begin{aligned} 
\sum_{k \in G_i}2^k=\sum_{k \in G_j}2^k \\
2^{i_1}+2^{i_2}+...+2^{i_p} = 2^{j_1}+2^{j_2}+...+2^{j_q} \\
1+2^{i_2-i_1}+...+2^{i_p-i_1}=2^{j_1-i_1}+2^{j_2-i_1}+...+2^{j_q-i_1}
\end{aligned}
\]</span> Since <span class="math inline">\(G_i \cap G_j=\phi\)</span> and neither <span class="math inline">\(G_i\)</span> or <span class="math inline">\(G_j\)</span> contains the index of <span class="math inline">\(0\)</span>, therefore the left-hand side of equation is odd and the right-hand side is even, which contradicts the previous assumption of equivalence of internal summation of <span class="math inline">\(G_i\)</span> and <span class="math inline">\(G_j\)</span>.</p>
<p>Thus, we can prove that the summation of any <span class="math inline">\(S\)</span> is unique, which further proves one-to-one mapping relation that for any positive integer <span class="math inline">\(m \leq 2^{n}-1\)</span>，there exists a unique set <span class="math inline">\(S \subseteq \{0,1,2,...,n-1\}\)</span> and <span class="math inline">\(S\neq \phi\)</span> such that <span class="math inline">\(m=\sum_{i\in S}2^{i}\)</span>.</p>
<p>实际上我们可以通过二进制来看出一些端倪，比如 <span class="math display">\[
\begin{aligned}11010110_{2} = \\
&amp; 10000000_2+ \\
&amp; 01000000_2+ \\
&amp; 00010000_2+ \\
&amp; 00000100_2 + \\
&amp; 00000010_2
\end{aligned}
\]</span> 我们可以看到，任意一个整数都可以用二进制来表示，然后它的位数计算其实就是我们的拆分方式。</p>
<h3 id="可行性问题的ovn算法">可行性问题的<span class="math inline">\(O(VN)\)</span>算法</h3>
<p>如果问题考察的是"每种有若干件的物品能否填满给定容量的背包"，只要考虑填满背包的可行性，不需考虑没见物品的价值时，多重背包问题可以有<span class="math inline">\(O(VN)\)</span>复杂度的算法。</p>
<p>事实上，0-1背包问题的装满可行性算法就是<span class="math inline">\(O(VN)\)</span>，所以比较直观的想法是利用上述拆分法将多重背包问题转换成0-1背包问题，然后解决，不过此时的时间复杂度是<span class="math inline">\(O(V\sum{M_i})\)</span>。</p>
<p>所以我们需要对子状态进行重新定义：</p>
<p><span class="math inline">\(F[i,v]\)</span>表示用前<span class="math inline">\(i\)</span>种物品填满容量为<span class="math inline">\(v\)</span>的背包后，还剩下多少个第<span class="math inline">\(i\)</span>种物品可用。定义<span class="math inline">\(F[i,V]=-1\)</span>为不合法，即未填满或无剩下。所以我们只要判断前<span class="math inline">\(i\)</span>物品填满容量为<span class="math inline">\(V\)</span>的背包后是否等于<span class="math inline">\(-1\)</span>就可以知道能否装满了。</p>
<p>伪代码：</p>
<img src="/2020/06/02/Knapsack1/image-20200602164925985.png" class="" title="pseudocode_04">
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFullPack</span><span class="params">(N, V, C, M)</span>:</span></span><br><span class="line">    Ns = N + <span class="number">1</span></span><br><span class="line">    Vs = V + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">-1</span>] * Vs</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V):</span><br><span class="line">            <span class="keyword">if</span> dp[v] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[v] = M[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">elif</span> dp[v] == <span class="number">-1</span>:</span><br><span class="line">                dp[v] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(C[i<span class="number">-1</span>], Vs):</span><br><span class="line">            dp[v] = max(dp[v-C[i<span class="number">-1</span>]]<span class="number">-1</span>, dp[v])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>] &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第二层循环中的第一层循环是初始化当前物品的<span class="math inline">\(M_i\)</span>在各个合法entry中的值，表明当前所有塞满的背包剩下最多<span class="math inline">\(M_i\)</span>的第<span class="math inline">\(i\)</span>件物品；</p>
<p>第二层循环中的第二层循环是便是状态转移方程的实现， <span class="math display">\[
F[i,v] = \max (F[i,v-C_i]-1,F[i,v])
\]</span> 为什么要定义最多剩下呢？这是一种贪婪的想法，我们需要尽可能的为后面的装填留更多的物品。</p>
<h2 id="例题">例题</h2>
<h4 id="零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4>
<p>咱们接下来看一到经典例题，零钱兑换。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        Ns = len(coins) + <span class="number">1</span></span><br><span class="line">        Vs = amount + <span class="number">1</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * Vs</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, Ns):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(coins[i<span class="number">-1</span>], Vs):</span><br><span class="line">                dp[v] = min(dp[v], dp[v-coins[i<span class="number">-1</span>]]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[<span class="number">-1</span>] == float(<span class="string">'inf'</span>) <span class="keyword">else</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>这道题其实也可以转换成背包问题，我们把amount看作这个背包的容量，硬币就是价值为<span class="math inline">\(1\)</span>的物品，硬币的面值看作每件物品的费用。为什么我们把硬币的价值作为<span class="math inline">\(1\)</span>来处理呢？其实我们可以定义子状态<span class="math inline">\(F[i,v]\)</span>为前<span class="math inline">\(i\)</span>种物品要装满容量为<span class="math inline">\(v\)</span>的背包至少所需要的件数，这和我们把硬币的价值看作<span class="math inline">\(1\)</span>其实是一样的。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和问题集</title>
    <url>/2020/06/02/PrefixSum/</url>
    <content><![CDATA[<h4 id="每个元音包含偶数次的最长子字符串"><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h4>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        status = <span class="number">0</span></span><br><span class="line">        pos = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; <span class="number">5</span>)]</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'a'</span>:</span><br><span class="line">                status ^= <span class="number">1</span> &lt;&lt; <span class="number">4</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'e'</span>:</span><br><span class="line">                status ^= <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'i'</span>:</span><br><span class="line">                status ^= <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'o'</span>:</span><br><span class="line">                status ^= <span class="number">1</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'u'</span>:</span><br><span class="line">                status ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pos[status] == <span class="number">-1</span>:</span><br><span class="line">                pos[status] = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = max(ret, i+<span class="number">1</span>-pos[status])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>这个问题的关键在于利用前缀和来确定子串的状态。这里的前缀和定义为前<span class="math inline">\(i\)</span>个字符中，每个元音字符出现的奇偶性，用来代替出现的次数。我们用二进制编码来代替状态的哈希结构，比如前<span class="math inline">\(i\)</span>个字符a, e, i, o, u出现的次数的奇偶性分别为奇，奇，偶，偶，偶，则其编码为<code>11000</code>。只要我们知道前<span class="math inline">\(i\)</span>个字符的状态和前<span class="math inline">\(j\)</span>个字符的状态，我们就可以知道从第<span class="math inline">\(i+1\)</span>个字符到第<span class="math inline">\(j\)</span>个字符的元音出现次数奇偶性状态，也就是只要前<span class="math inline">\(i\)</span>个字符的二进制编码和前<span class="math inline">\(j\)</span>个字符的二进制编码相同，我们就可以确定<span class="math inline">\(i+1\)</span>到<span class="math inline">\(j\)</span>元音出现次数为偶数。原因在于差为偶则被减数和减数奇偶性相同。</p>
<p>难点1：前缀和由出现次数转换为奇偶性</p>
<p>优化点1：二进制编码</p>
<p>优化点2：抛弃哈希记录每个字符的前缀和，反而用编码作为key来记录该前缀和出现的index，将时间复杂度从<span class="math inline">\(O(n^2)\)</span>降至<span class="math inline">\(O(n)\)</span></p>
<p>边界点1：<code>pos[0]=0</code>，原因在于非原因字符最早出现的index一定是空字符串</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关问题集</title>
    <url>/2020/06/02/Tree/</url>
    <content><![CDATA[<h4 id="从前序与中序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root_index = inorder.index(root.val)</span><br><span class="line">        left_inorder = inorder[:root_index]</span><br><span class="line">        right_inorder = inorder[root_index+<span class="number">1</span>:]</span><br><span class="line">        left_preorder = preorder[<span class="number">1</span>:<span class="number">1</span>+len(left_inorder)]</span><br><span class="line">        right_preorder = preorder[<span class="number">1</span>+len(left_inorder):]</span><br><span class="line">        root.left = self.buildTree(left_preorder, left_inorder)</span><br><span class="line">        root.right = self.buildTree(right_preorder, right_inorder)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>序列化和反序列化二叉树步骤之一，通过前序遍历和中序遍历构造二叉树。要点在于通过前序序列知道根节点，通过中序序列知道左子树和右子树是哪些。</p>
<p>边界点：递归约束，叶节点的子节点None停止递归，通过判断preorder是否为空判断该节点是否为None。</p>
<h4 id="对称二叉树"><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p.val == q.val) &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(N)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O(N)\)</span> 原因在于虽然我们只需要递归<span class="math inline">\(O(\log N)\)</span>层但是我们每层都要创建2个栈空间，所以我们的空间复杂度为<span class="math inline">\(O(2^{\log N})=O(N)\)</span></p>
<p>难点：注意镜像，所以我们需要 <code>check(p.left, q.right) &amp;&amp; check(p.right, q.left);</code></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript DOM编程艺术》第三章读书笔记</title>
    <url>/2020/06/02/jsdom3/</url>
    <content><![CDATA[<h2 id="dom解释">DOM解释</h2>
<ul>
<li>D: 网页文档</li>
<li>O：对象，自足的数据集合。JS里的对象可以分为三种类型
<ol type="1">
<li>用户定义对象(user-defined object): 由程序员自行创建的对象</li>
<li>内建对象(native object): 内建的js对象，如Array，Math</li>
<li>宿主对象(host object): 由浏览器提供的对象</li>
</ol></li>
<li>M： (X)HTML所代表的节点树模型 <a id="more"></a> ## 元素节点 元素节点时DOM中的原子，其包含文本节点和属性节点。<code>&lt;P&gt;</code>为元素节点，<code>&lt;p&gt;xxx&lt;/p&gt;</code>包含的xxx为文本节点，<code>&lt;p title='x'&gt;&lt;/p&gt;</code>中的title为属性节点</li>
</ul>
<h2 id="获取元素节点">获取元素节点</h2>
<ol type="1">
<li>getElementById <code>document.getElementById("&lt;id&gt;")</code></li>
<li>getElementsByTagName 返回一个<code>对象数组</code>，每个对象分别对应这文档里给定标签的一个元素。 <code>document.getElementsByTagName("li")</code> 如果你想知道某份文档里共有多少个元素节点，可以使用通配符 <code>document.getElementsByTagName("*").length</code> 话可以将<code>getElementById</code>和<code>getElementsByTagName</code>结合起来， <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = <span class="built_in">document</span>.getElementById(<span class="string">"purchases"</span>);</span><br><span class="line"><span class="keyword">var</span> items = shopping.getElementsByTagName(<span class="string">"*"</span>);</span><br></pre></td></tr></table></figure></li>
<li>getElementsByClassName 返回一个具有相同类名的元素的数组。 <code>document.getElementsByClassName("sale);</code></li>
</ol>
<h2 id="获取和设置属性">获取和设置属性</h2>
<ol type="1">
<li>getAttribute 该方法不属于<code>document</code>对象，所以不能通过其调用，它只能通过元素节点对象吊桶。 <code>object.get.Attribute(attribute);</code></li>
<li>setAttribute <code>object.setAttribute(attribute, value);</code></li>
</ol>
<p><strong>通过setAttribute()方法对文档作出的改变，但这张改变并未反映到源代码中，也就是说，源代码中属性值仍旧是原来的属性值。这种“表里不一”的现象缘于DOM的工作模式：先加载文档的静态内容，再以动态方式对它们进行刷新，动态刷新不改变文档的静态内容，而对页面内容的刷新，不需要用户在他们的浏览器里执行刷新操作就可以实现。</strong></p>
<p>个人对这句话的理解时，你在console中运行setAttribute的DOM操作不会影响静态的html源代码，但是浏览器已经将你的修改运行到了渲染中。比如你在console中修改attribute <code>href</code>, 源代码不会改变，但是你点击的那个超链接已经发生了改变。</p>
]]></content>
      <categories>
        <category>Frontend</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>DOM Scripting Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 入门</title>
    <url>/2020/06/21/SQL-Intro/</url>
    <content><![CDATA[<p>学习笔记 of <a href="https://www.liaoxuefeng.com/wiki/1177760294764384" target="_blank" rel="noopener">廖雪峰SQL教程</a></p>
<a id="more"></a>
<h2 id="关系模型">关系模型</h2>
<p><code>Record</code>: 每一行称为记录</p>
<p><code>Column</code>: 每一列称为字段</p>
<p><code>NULL</code>: 表示数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>''</code>。</p>
<p><code>主键</code>: 通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p>
<blockquote>
<p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<strong><em>不可</em></strong>用作主键。</p>
</blockquote>
<p><code>id</code>字段：</p>
<ol type="1">
<li><p>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</p></li>
<li><p>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</p>
<blockquote>
<p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p>
</blockquote></li>
</ol>
<p><code>联合主键</code>:关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p>
<blockquote>
<p>如无必要，勿用联合主键，复杂度上升</p>
</blockquote>
<p><code>外键</code>: 在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p>
<p>定义外键约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure>
<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p>
<blockquote>
<p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p>
</blockquote>
<h2 id="基本操作">基本操作</h2>
<h3 id="查询">查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;table_name&gt;</span><br></pre></td></tr></table></figure>
<p>判断当前到数据库的链接是否有效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="条件查询">条件查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> &lt;条件表达式&gt;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>查询分数在80分以上的学生记录</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score &gt;= <span class="number">80</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>查询分数在80分及以上的男生</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score &gt;= <span class="number">80</span> <span class="keyword">AND</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>查询分数在80分及以上的学生或者男生</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score &gt;= <span class="number">80</span> <span class="keyword">OR</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>查询不是2班的学生</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">NOT</span> class_id = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>分数在80以下或者90以上，并且是男生</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> (score &lt; <span class="number">80</span> <span class="keyword">OR</span> score &gt; <span class="number">90</span>) <span class="keyword">AND</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">条件</th>
<th style="text-align: left;">表达式举例1</th>
<th style="text-align: left;">表达式举例2</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">使用=判断相等</td>
<td style="text-align: left;">score = 80</td>
<td style="text-align: left;">name = 'abc'</td>
<td style="text-align: left;">字符串需要用单引号括起来</td>
</tr>
<tr class="even">
<td style="text-align: left;">使用&gt;判断大于</td>
<td style="text-align: left;">score &gt; 80</td>
<td style="text-align: left;">name &gt; 'abc'</td>
<td style="text-align: left;">字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr class="odd">
<td style="text-align: left;">使用&gt;=判断大于或相等</td>
<td style="text-align: left;">score &gt;= 80</td>
<td style="text-align: left;">name &gt;= 'abc'</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">使用&lt;判断小于</td>
<td style="text-align: left;">score &lt; 80</td>
<td style="text-align: left;">name &lt;= 'abc'</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">使用&lt;=判断小于或相等</td>
<td style="text-align: left;">score &lt;= 80</td>
<td style="text-align: left;">name &lt;= 'abc'</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">使用&lt;&gt;判断不相等</td>
<td style="text-align: left;">score &lt;&gt; 80</td>
<td style="text-align: left;">name &lt;&gt; 'abc'</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">使用LIKE判断相似</td>
<td style="text-align: left;">name LIKE 'ab%'</td>
<td style="text-align: left;">name LIKE '%bc%'</td>
<td style="text-align: left;">%表示任意字符，例如'ab%'将匹配'ab'，'abc'，'abcd'</td>
</tr>
</tbody>
</table>
<h4 id="投影查询">投影查询</h4>
<ol type="1">
<li><p>从<code>students</code>表中返回id, score 和name这三列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score, <span class="keyword">name</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li>
<li><p>取列同时给每一列起个别名<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score pints, <span class="keyword">name</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li>
<li><p>加上<code>WHERE</code>实现复杂查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score points, <span class="keyword">name</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="排序">排序</h4>
<p>关键字：<code>ORDER BY</code></p>
<ol type="1">
<li><p>按成绩祷告进行排序（从低到高）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students ORRDER <span class="keyword">BY</span> score;</span><br></pre></td></tr></table></figure></li>
<li><p>加上<code>DESC</code>表示倒序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>按多列排序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender;</span><br></pre></td></tr></table></figure></li>
<li><p>带WHERE条件的ORDER BY：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> class_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="分页查询">分页查询</h4>
<p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p>
<ol type="1">
<li><p>给students排序并把结果而烦恼页，每页3条记录，获取第1页记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>LIMIT 3 OFFSET 0</code>表示对结果从0记录开始，最多取3条</p></li>
<li><p>查询第2页就是跳过头三条记录，从3好记录开始查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>如果<code>OFFSET</code>超过了查询的最大数量并不会报错。而是得到一个空的结果集。</p>
</blockquote>
<h4 id="聚合查询">聚合查询</h4>
<h5 id="统计数量">统计数量</h5>
<ol type="1">
<li><p>查询students表一共有多少记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">num</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。</p></li>
<li><p>查询有多少男生：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) boys <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="平均值">平均值</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(score) average <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SUM</td>
<td style="text-align: left;">计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr class="even">
<td style="text-align: left;">AVG</td>
<td style="text-align: left;">计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MAX</td>
<td style="text-align: left;">计算某一列的最大值</td>
</tr>
<tr class="even">
<td style="text-align: left;">MIN</td>
<td style="text-align: left;">计算某一列的最小值</td>
</tr>
</tbody>
</table>
<h5 id="分组聚合">分组聚合</h5>
<p>分组统计各个班男生和女生的人数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class_id, <span class="keyword">COUNT</span>(*) <span class="keyword">num</span> <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id, gender;</span><br></pre></td></tr></table></figure>
<h4 id="多表查询">多表查询</h4>
<p>从多张表同时查询数据：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code></p>
<ol type="1">
<li><p>得到students表和classes表的 乘积:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students, classes;</span><br></pre></td></tr></table></figure></li>
<li><p>实用表名来给列名做区分：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	s.id <span class="keyword">sid</span>,</span><br><span class="line">	s.name,</span><br><span class="line">	s.gender,</span><br><span class="line">	s.score,</span><br><span class="line">	c.id cid,</span><br><span class="line">	c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="连接查询">连接查询</h4>
<p>通过INNER JOIN将两张表连接起来</p>
<p>INNER JOIN写法：</p>
<ol type="1">
<li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li>
<li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li>
<li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li>
<li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li>
</ol>
<p>选出所有学生，同时返回班级的名称:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>JOIN type</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>INNER JOIN</td>
<td>只返回同时存在于两张表里的行数据</td>
</tr>
<tr class="even">
<td>RIGHT OUTER JOIN</td>
<td>只返回右表存在的行</td>
</tr>
<tr class="odd">
<td>LEFT OUTER JOIN</td>
<td>只返回左表存在的行</td>
</tr>
<tr class="even">
<td>FULL OUTER JOIN</td>
<td>把两张表的所有记录全部选择出来，并且自动在缺失的列填充为NULL</td>
</tr>
</tbody>
</table>
<h3 id="插入">插入</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>
<p>一次性增加多条新纪录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'大宝'</span>, <span class="string">'M'</span>, <span class="number">87</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'二宝'</span>, <span class="string">'M'</span>, <span class="number">81</span>);</span><br></pre></td></tr></table></figure>
<h3 id="更新">更新</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;form_name&gt; <span class="keyword">SET</span> column1=value1, column2=value2, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>更新<code>students</code>表<code>id=1</code>的记录的<code>name</code>和<code>score</code>这两个字段:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'大牛'</span>, score=<span class="number">66</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>把所有80分以下的同学的成绩加10分:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> score=score+<span class="number">10</span> <span class="keyword">WHERE</span> score&lt;<span class="number">80</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>如果<code>UPDATE</code>语句没有<code>WHERE</code>条件，整个表的所有记录都会被更新。所以，在执行<code>UPDATE</code>语句时要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出期望的记录集，然后再用<code>UPDATE</code>更新。</p>
</blockquote>
<p><a href="https://blog.csdn.net/yang_guang3/article/details/103232941" target="_blank" rel="noopener">避免生产环境执行更新删除语句忘记加where条件的解决方案</a></p>
<h3 id="删除">删除</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据。</p>
</blockquote>
<h2 id="mysql">MySQL</h2>
<p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p>
<p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p>
<blockquote>
<p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p>
</blockquote>
<p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql <span class="literal">-h</span> <span class="number">10.0</span>.<span class="number">1.99</span> <span class="literal">-u</span> root <span class="literal">-p</span></span><br></pre></td></tr></table></figure>
<h3 id="数据库">数据库</h3>
<p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shici              |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| school             |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p>
<p>要创建一个新数据库，使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE <span class="built_in">test</span>;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>要删除一个数据库，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p>
<p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>
<h3 id="表">表</h3>
<p>列出当前数据库的所有表，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<p>要查看一个表的结构，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESC students;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>还可以使用以下命令查看创建表的SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE students;</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">| students | CREATE TABLE &#96;students&#96; (                             |</span><br><span class="line">|          |   &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,            |</span><br><span class="line">|          |   &#96;class_id&#96; bigint(20) NOT NULL,                     |</span><br><span class="line">|          |   &#96;name&#96; varchar(100) NOT NULL,                       |</span><br><span class="line">|          |   &#96;gender&#96; varchar(1) NOT NULL,                       |</span><br><span class="line">|          |   &#96;score&#96; int(11) NOT NULL,                           |</span><br><span class="line">|          |   PRIMARY KEY (&#96;id&#96;)                                  |</span><br><span class="line">|          | ) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8 |</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure>
<p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure>
<p>要删除列，使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure>
<h3 id="退出mysql">退出MySQL</h3>
<p>使用<code>EXIT</code>命令退出MySQL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>
<p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p>
<h3 id="实用sql语句">实用SQL语句</h3>
<h4 id="插入或替换">插入或替换</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">'小明'</span>,<span class="string">'F'</span>,<span class="number">99</span>);</span><br></pre></td></tr></table></figure>
<h4 id="插入或更新">插入或更新</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">name</span>=<span class="string">'小明'</span>, gender=<span class="string">'F'</span>, score=<span class="number">99</span>;</span><br></pre></td></tr></table></figure>
<h4 id="插入或忽略">插入或忽略</h4>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">'小明'</span>,<span class="string">'F'</span>,<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<h4 id="快照">快照</h4>
<p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE</code>和<code>SELECT</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students_of_class1 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="查询结果写入表">查询结果写入表</h4>
<p>创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">	id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>然后写插入平均成绩的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">statistics</span> (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure>
<h4 id="强制使用指定索引">强制使用指定索引</h4>
<p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id &#x3D; 1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure>
<p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p>
<h2 id="事务">事务</h2>
<p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从id&#x3D;1的账户给id&#x3D;2的账户转账100元</span><br><span class="line">-- 第一步：将id&#x3D;1的A账户余额减去100</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance - 100 WHERE id &#x3D; 1;</span><br><span class="line">-- 第二步：将id&#x3D;2的B账户余额加上100</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance + 100 WHERE id &#x3D; 2;</span><br></pre></td></tr></table></figure>
<p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p>
<p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p>
<p><strong>事务的ACID特性</strong></p>
<ul>
<li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ul>
<blockquote>
<p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p>
</blockquote>
<p>使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把转账操作作为一个显式事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance - 100 WHERE id &#x3D; 1;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance + 100 WHERE id &#x3D; 2;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Isolation Level</th>
<th style="text-align: left;">脏读（Dirty Read）</th>
<th style="text-align: left;">不可重复读（Non Repeatable Read）</th>
<th style="text-align: center;">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Read Uncommitted</td>
<td style="text-align: left;">Yes</td>
<td style="text-align: left;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read Committed</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Repeatable Read</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Serializable</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h4 id="read-uncommitted">Read Uncommitted</h4>
<p>Read Uncommitted是隔离级别最低的一种事务级别。</p>
<ol type="1">
<li>脏读（Dirty Read）</li>
</ol>
<p>在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读。</p>
<ol start="2" type="1">
<li>不可重复读（Non Repeatable Read）</li>
</ol>
<p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p>
<h4 id="repeatable-read">Repeatable Read</h4>
<ol type="1">
<li><p>幻读（Phantom Read）：</p>
<p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p></li>
</ol>
<h4 id="serializable">Serializable</h4>
<p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript DOM编程艺术》第六章读书笔记</title>
    <url>/2020/06/21/jsdom6/</url>
    <content><![CDATA[<h3 id="分离js和html">分离JS和HTML</h3>
<p>作为一条原则，如果想用JavaScript给某哥网页添加一些行为，就不应该让JavaScript代码对这个网页的结构有任何依赖。</p>
<a id="more"></a>
<p>比如加上如下的检测，来探测浏览器是否支持这些DOM。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">document</span>.getElementsByTagName) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">document</span>.getElementById) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">document</span>.getElementById(<span class="string">"imagegallery"</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="共享onload事件">共享onload事件</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLoadEvent</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.onload = func;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      oldonload();</span><br><span class="line">      func();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addLoadEvent(firstFunction);</span><br><span class="line">addLoadEvent(secondFunction);</span><br></pre></td></tr></table></figure> 取代</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = firstFunction;</span><br><span class="line"><span class="built_in">window</span>.onload = secondFunction;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Frontend</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>DOM Scripting Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript DOM编程艺术》第四章读书笔记</title>
    <url>/2020/06/02/jsdom4/</url>
    <content><![CDATA[<p>这里我们主要谈的是html上对用户事件的处理。</p>
<h2 id="事件处理函数">事件处理函数</h2>
<p>时间处理函数的作用是，在特定时间发生时调用特定的JavaScript代码。 <a id="more"></a> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"images/fireworks.jpg"</span> <span class="attr">title</span>=<span class="string">"A fireworks display"</span> <span class="attr">onclick</span>=<span class="string">"showPic(this); return false;"</span>&gt;</span></span><br><span class="line">Fireworks<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPic</span>(<span class="params">pic</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> source = pic.getAttribute(<span class="string">"href"</span>);</span><br><span class="line">  <span class="keyword">let</span> placeholder = <span class="built_in">document</span>.getElementById(<span class="string">"placeholder"</span>);</span><br><span class="line">  placeholder.setAttribute(<span class="string">"src"</span>, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>this</code>表示这个<code>&lt;a&gt;</code>元素节点</li>
<li><code>event = "JS statements"</code>来添加事件处理函数的语法</li>
<li>如果仅仅把使劲按处理函数放到图片列表的一个链接中，我们会遇到一个问题：点击这个链接时，不仅<code>showPic</code>函数被调用，链接被点击的默认行为也会被调用。这意味着用户还是会被带到图片查看窗口。我们需要组织这个默认行为被调用。</li>
</ul>
<p>一旦事件发生，相应的js代码就会得到执行。被调哦那个的js代码可以返回一个值，这个值将被传递给那个时间处理函数，并让这个处理函数出发的js代码返回布尔值true或false。如果返回的时true，onclick时间处理函数九认为"这个链接被点击了"；反之，如果返回的值时false，onclick时间处理函数就认为"这个链接没有被点击"。因此，<code>return false;</code>可以防止用户被带到目标链接窗口。</p>
<h3 id="nodetype属性">nodeType属性</h3>
<p><code>node.nodeType</code>获取节点的nodeType属性。 nodeType属性总共有12种，期中仅有3种具有实用价值：</p>
<ul>
<li>元素节点：1</li>
<li>属性节点：2</li>
<li>文本节点：3</li>
</ul>
<h3 id="替代文本节点">替代文本节点</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPic</span>(<span class="params">whichpic</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> source = whichpic.getAttribute(<span class="string">"href"</span>);</span><br><span class="line">  <span class="keyword">var</span> placeholder = <span class="built_in">document</span>.getElementById(<span class="string">"placeholder"</span>);</span><br><span class="line">  placeholder.setAttribute(<span class="string">"src"</span>,source);</span><br><span class="line">  <span class="keyword">var</span> text = whichpic.getAttribute(<span class="string">"title"</span>);</span><br><span class="line">  <span class="keyword">var</span> description = <span class="built_in">document</span>.getElementById(<span class="string">"description"</span>);</span><br><span class="line">  description.firstChild.nodeValue = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们通过firstChild来渠道<code>&lt;p&gt;</code>元素节点的文本节点。如果该元素节点有包含文本的话，那么该元素的firstChild就为文本节点，否则时其他（元素）节点。</p>
<ul>
<li><code>node.nodeValue</code>: 取文本节点的值</li>
<li><code>node.firstChild</code>: 等价于<code>node.childNodes[0]</code></li>
<li><code>node.lastChild</code>: 等价于<code>node.childNodes[node.childNodes.length-1]</code></li>
</ul>
]]></content>
      <categories>
        <category>Frontend</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>DOM Scripting Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript DOM编程艺术》第五章读书笔记</title>
    <url>/2020/06/02/jsdom5/</url>
    <content><![CDATA[<p>JavaScript平稳退化，兼容和性能问题(tips)。 <a id="more"></a></p>
<h1 id="js平稳退化">JS平稳退化</h1>
<p>Javascript作为一种前端脚本语言，主要功能是用于改善前端的用户体验。我们看见一些网页的显示效果，比方说菜单显示隐藏，图标移动和文字滚动大多是基于JS来实现的。作为改善用户体验的存在，通俗的讲就是起个锦上添花的表现效果，而不能影响正常的后台逻辑和最基本功能的实现。</p>
<p>通俗地讲，javascript平稳退化就是如果一个浏览器完全不支持js或者禁用js的时候，它的正常功能不会受到任何影响。</p>
<h3 id="打开新窗口">打开新窗口</h3>
<p><code>window.open(url,name,features)</code> - 第一个参数是想在新窗口里打开的网页的URL地址。如果省略这个参数，屏幕上将弹出一个空白的浏览器窗口。 - 第二个参数是新窗口的名字。可以在代码里通过这个名字和新窗口进行通信。 - 最后一个参数是一个以都好分隔的字符串，其内容是新窗口的各种属性。这些属性包括新窗口的尺寸（宽度和高度）以及新窗口被启用或禁用的各种浏览功能（工具条，菜单条，初始先是位置等)。对于这个桉树应该掌握以下原则：新窗口的浏览功能要少而精。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popUp</span>(<span class="params">winURL</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(winURL, <span class="string">"popup"</span>, <span class="string">"width=320,height=480"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="javascript-伪协议">Javascript 伪协议</h4>
<p><code>javascript:</code>伪协议让我们通过一个链接来调用JavaScript函数。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:popUp('http://www.example.com/');"</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> 这条语句在支持"javascript:"伪协议的浏览器中运行正常，较老的浏览器则会取尝试打开那个链接但失败，支持这种协议单禁用了javascript功能的浏览器会什么也不做。</p>
<h4 id="内嵌事件处理函数">内嵌事件处理函数</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"popUp('http://www.example.com/'); return false;"</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所有操作由onclick属性负责完成，无法平稳退化。</p>
<h4 id="需要平稳退化的原因">需要平稳退化的原因</h4>
<p>如果用户是一个<strong>搜索机器人</strong>，一种自动化程序，它们浏览Web的目的是为了把各种网页添加到搜索引擎的数据库里。各大搜索引擎都有类似的程序。目前。只有极少数搜索机器人能够理解js代码。所以，如果js网页不能平稳退化，它们在搜索引擎上的排名就可能受到损害。</p>
<p>所以我们最好修改成如下 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/"</span> <span class="attr">onclick</span>=<span class="string">"popUp(this.href);return false;"</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分离javascript">分离JavaScript</h3>
<p>HTML Document: <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/"</span> <span class="attr">class</span>=<span class="string">"popup"</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> 我们可以在外部把一个事件添加到html文档中的某个元素上： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.event = action...</span><br></pre></td></tr></table></figure> 比如： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getElementById(id).event = action;</span><br></pre></td></tr></table></figure> 如果事件涉及多个元素，我们可以用getElementsByTagName和getAttribute把事件添加到有着特定属性的一组元素上。 具体步骤：</p>
<ol type="1">
<li>把文档里所有的链接全放入一个数组里</li>
<li>遍历数组</li>
<li>如果某个链接的class属性等于popup，就表示这个链接在被点击时应该调用popUp()函数。</li>
</ol>
<p>还有一个问题是必须让这种连接的代码在html文档全部加载到浏览器后再开始执行。文档将被加载到一个浏览器窗口里，document对象又是window对象的一个属性。当window对象触发onload事件时，document对象已经存在。 所以我们在外部的js文件里这样写 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = preparelinks;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareLinks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> links = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;links.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (links[i].getAttribute(<span class="string">"class"</span>) == <span class="string">"popup"</span>) &#123;</span><br><span class="line">            links[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                popUp(<span class="keyword">this</span>.getAttribute(<span class="string">"href));</span></span><br><span class="line"><span class="string">                return false;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function popUp(winURL) &#123;</span></span><br><span class="line"><span class="string">    window.open(winURL, "</span>popup<span class="string">", "</span>width=<span class="number">800</span>,height=<span class="number">600</span><span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="向后兼容">向后兼容</h3>
<h4 id="对象检测">对象检测</h4>
<p>检测浏览器对js的支持程度 比如 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">document</span>.getElementsByTagName) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="性能考虑">性能考虑</h3>
<ol type="1">
<li>介绍不必要的DOM访问</li>
<li>合并多个js文件到一个文件里</li>
<li>压缩脚本，去掉不必要的字节如空格和注释 多数情况下，你应该有两个版本，一个是工作副本，可以修改代码并添加注释；另一个时精简副本，用于放在站点上。通常，为了与非精简版本区分开，最好在精简副本的文件名中加上min字样： <code>&lt;script src="scripts/scriptName.min.js"&gt;&lt;/script&gt;</code></li>
</ol>
<p>可以通过以下几个有代表性的代码压缩工具完成：</p>
<ul>
<li><a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">Uglify</a></li>
<li><a href="http://developer.yahoo.com/yui/compressor/" target="_blank" rel="noopener">YUI Compressor</a></li>
<li><a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Google Closure Compiler</a></li>
<li><a href="https://tool.oschina.net/jscompress/" target="_blank" rel="noopener">oschina 在线js压缩</a></li>
</ul>
]]></content>
      <categories>
        <category>Frontend</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>DOM Scripting Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>字节校招凉经20200804</title>
    <url>/2020/08/04/%E5%AD%97%E8%8A%82%E6%A0%A1%E6%8B%9B%E5%87%89%E7%BB%8F20200804/</url>
    <content><![CDATA[<p>字节跳动 飞书后端开发</p>
<p>校招 一面 提前批 <a id="more"></a></p>
<ol type="1">
<li><p>自我介绍</p></li>
<li><p>线程与进程的区别</p></li>
<li><p>线程如何实现并行</p></li>
<li><p>死锁产生的原因</p></li>
<li><p>如何解开死锁</p></li>
<li><p>为什么会出现乱码</p></li>
<li><p>什么场景会出现乱码</p></li>
<li><p>有哪些编码规则</p></li>
</ol>
<blockquote>
<p>字符集：像Unicode 是为所有字符安排一个编号(ID), 如“知”的unicode为0x77e5 编码: 一种双射规则将这个ID转换成二进制序列方便存储和传输</p>
</blockquote>
<ol start="9" type="1">
<li>UTF-8是怎样的</li>
</ol>
<blockquote>
<p>UTF-8是这样做的： 1. 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同； 2. n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p>
</blockquote>
<ol start="10" type="1">
<li><p>Python 如何充分利用多核cpu实现并行 (说了自己比较熟悉python，结果那2个月一直在写go)</p></li>
<li><p>了解过redis或memcache 吗 （无）</p></li>
<li><p>在浏览器输入url后拿到页面的过程中发生了什么</p></li>
<li><p>HTTP 的请求头有哪些</p></li>
<li><p>GET方法和POST方法的区别</p></li>
<li><p>GET方法可以传BODY吗 （可）</p></li>
<li><p>DNS 的功能</p></li>
<li><p>TCP三次握手，四次挥手</p></li>
<li><p>为什么要三次握手和四次挥手</p></li>
<li><p>四次挥手后，主动关闭端处于怎样的状态</p></li>
<li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a> 6个月前做过啊，现场没写出来，后面重新写出来的解答</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: str)</span> -&gt; int:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    hashMap = &#123;&#125;</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; len(s):</span><br><span class="line">        <span class="keyword">if</span> hashMap.get(s[j], <span class="number">-1</span>) == <span class="number">-1</span>:</span><br><span class="line">            hashMap[s[j]] = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_i = hashMap[s[j]] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; next_i:</span><br><span class="line">                hashMap[s[i]] = <span class="number">-1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            hashMap[s[j]] = j</span><br><span class="line">        max_len = max(max_len, j-i+<span class="number">1</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<p>虽然没有把重心放在秋招上，但还是记录一下这份无知，希望明年这时候看到这篇面筋的我能够不再对面试感到害怕。</p>
]]></content>
      <tags>
        <tag>面筋</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript DOM编程艺术》第七章读书笔记</title>
    <url>/2020/06/21/jsdom7/</url>
    <content><![CDATA[<p>动态创建标记 <a id="more"></a></p>
<h2 id="dom方法">DOM方法</h2>
<h3 id="createelement">createElement</h3>
<p>目标：将一段文本插入如下testdiv元素 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"testdiv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>创建一个新的元素；</li>
<li>把这个新元素插入节点树。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>); <span class="comment">// 文档碎片</span></span><br><span class="line"><span class="keyword">var</span> testdiv = <span class="built_in">document</span>.getElementById(<span class="string">"testdiv"</span>);</span><br><span class="line">testdiv.appendChild(para);</span><br></pre></td></tr></table></figure>
<h3 id="createtextnode">createTextNode</h3>
<p>注意<code>createElement</code>和<code>createTextNode</code>的区别。</p>
<p>创建文本节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createTextNode(<span class="string">"Hello World"</span>);</span><br><span class="line"><span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello World"</span>);</span><br><span class="line">para.appendChild(txt);</span><br></pre></td></tr></table></figure>
<h4 id="例子">例子</h4>
<p>插入一个简单的元素 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is <span class="tag">&lt;<span class="name">em</span>&gt;</span>my<span class="tag">&lt;/<span class="name">em</span>&gt;</span> content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure> 节点树：</p>
<p><img src="D:\CUHKSZ\OneDrive - CUHK-ShenZhen\SharedDocuments\Hexo_blogs\Frontend\notes\jsdom7.assets\image-20200607171033679.png" alt="image-20200607171033679" style="zoom:50%;" /></p>
<p>代码： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> txt1 = <span class="built_in">document</span>.createTextNode(<span class="string">"This is "</span>);</span><br><span class="line"><span class="keyword">var</span> em = <span class="built_in">document</span>.createElement(<span class="string">'em'</span>);</span><br><span class="line"><span class="keyword">var</span> em_txt = <span class="built_in">document</span>.createTextNode(<span class="string">"my"</span>);</span><br><span class="line"><span class="keyword">var</span> txt2 = <span class="built_in">document</span>.createTextNode(<span class="string">" content."</span>);</span><br><span class="line">para.appendChild(txt1);</span><br><span class="line">em.appendChild(em_txt);</span><br><span class="line">para.appendChild(txt3);</span><br><span class="line"><span class="keyword">var</span> testdiv = <span class="built_in">document</span>.getElementById(<span class="string">"testdiv"</span>);</span><br><span class="line">testdiv.appendChild(para);</span><br></pre></td></tr></table></figure></p>
<h3 id="在已有元素前插入一个新元素">在已有元素前插入一个新元素</h3>
<p>DOM提供了名为insertBefore()方法，这个方法将把一个新元素插入到一个现有元素的前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parentElement.insertBefore(newElement,targetElement);</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>新元素：你想插入的元素(newElement)</li>
<li>目标元素：你想把这个新元素插入到哪个元素(targetElement)之前</li>
<li>父元素：目标元素的父元素(parentElement)</li>
</ol>
<p>我们可以通过targetEleent元素的parentNode来找到parentElement</p>
<h3 id="在现有方法后插入一个新元素">在现有方法后插入一个新元素</h3>
<h4 id="编写insertafter函数">编写insertAfter函数</h4>
<p>实用已知的方法来编写一个insertAfter函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAfter</span>(<span class="params">newElement, targetElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = targetElement.parentNode;</span><br><span class="line">    <span class="keyword">if</span> (parent.lastChild == targetElement) &#123;</span><br><span class="line">        parent.appendChild(newElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       parent.insertBefore(newElement,targetElement.nextSibling);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ajax">Ajax</h2>
<p>实用Ajax可以做到只更新页面中的一小部分。其他内容——标志、导航、头部、脚部，都不用重新加载。用户仍然像往常一样点击链接，但这一次，已经加载的页面中只有一小部分区域会更新，而不必再次加载整个页面了。</p>
<p>Ajax的主要优势就是对页面的请求以异步方式发送到服务器。而服务器不会用整个页面来响应请求，它会在后台处理请求，与此同时用户还能继续浏览页面并与页面交互。你的脚本则可以按需加载和创建页面内容，而不会打断用户的浏览体验。</p>
<p>Ajax的核心是XMLHttpRequest对象。JS可以通过这个对象发送请求，然后自己处理响应。<strong>不同浏览器实现XMLHttpRequest</strong>的方式不太一样，为了保证跨浏览器，不得不为同样的事情写不同的分支。</p>
<p>这是我们的html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"new"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/addLoadEvent.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/getHttpObject.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/getNewContent.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了兼容所有浏览器（包括IE），<code>getHttpObject.js</code>中的<code>getHTTPObject</code>需要这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHTTPObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest == <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        XMLHttpRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP.6.0"</span>); &#125;</span><br><span class="line">                <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP.3.0"</span>); &#125;</span><br><span class="line">                <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>); &#125;</span><br><span class="line">                <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来写一个Ajax的HTTP请求。XMLHttpReuqest的open方法可以用来指定服务器上将要访问的文件，指定请求类型：GET，POST或SEND。这个方法的第三个参数用于指定亲贵是否以异步的方式就发送和处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNewContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = getHTTPObject();</span><br><span class="line">    <span class="keyword">if</span> (request) &#123;</span><br><span class="line">        request.open(<span class="string">"GET"</span>, <span class="string">"example.txt"</span>, <span class="literal">true</span>);</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (request.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">                <span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(request.responseText);</span><br><span class="line">                para.appendChild(txt);</span><br><span class="line">                <span class="built_in">document</span>.getElementById(<span class="string">'new'</span>).appendChild(para);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.send(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Sorry, your browser does not support XMLHttpRequest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addLoadEvent(getNewContent);</span><br></pre></td></tr></table></figure>
<p><code>onreadystatechange</code>是一个事件处理函数，它会在服务器给XMLHttpRequest对象送回响应的时候被触发执行。在这个处理函数中，可以更具服务区的具体响应做出相应处理。</p>
<p>在指定了请求的目标，也明确了如何处理响应后，就可以用send方法来发送请求了：<code>request.send(null);</code></p>
<p>服务器在像XMLHttpRequest对象时，该对象有许多属性可用，浏览器会在不同阶段更新readyState属性的值，它有5个可能的值：</p>
<ul>
<li>0表示未初始化</li>
<li>1表示正在加载</li>
<li>2表示加载完毕</li>
<li>3表示正在交互</li>
<li>4表示完成</li>
</ul>
<p>只要readState属性的值编程了4，就可以访问服务器发送回来的数据了。返回的数据主要有两个属性。一个是<code>responseText</code>，用于保存文本字符串形式的数据；另一个是<code>responseXML</code>用于保存Content-Type头部中指定为"text/xml"的数据，其实是一个DocumentFragment（文档碎片）对象。</p>
<blockquote>
<p>异步请求有一个容易被忽略的问题就是异步性，就是脚本在发送XMLHttpRequest亲求后，仍然会继续执行，不会等待响应返回。</p>
</blockquote>
<h4 id="hijax">Hijax</h4>
<p>拦截用户操作触发的默认请求，然后使用Ajax操作。在做到平稳退化的基础之上利用Ajax渐进增强。</p>
]]></content>
      <categories>
        <category>Frontend</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>DOM Scripting Notes</tag>
      </tags>
  </entry>
</search>
